#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#define N 9

void printGrid(int grid[N][N])
{
    printf(" -------------------------------------------\n");
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            if (j == 0)
            {
                printf(" |");
            }
            printf("%3d ", grid[i][j]);
            if ((j + 1) % 3 == 0)
                printf(" |");
        }
        printf("\n");
        if ((i + 1) % 3 == 0)
        {
            printf(" -------------------------------------------\n");
        }
    }
}
char isValid(int grid[N][N], int row, int col, int num)
{

    for (int i = 0; i < N; i++)
    {
        if (grid[row][i] == num || grid[i][col] == num)
        {
            return 0;
        }
    }
    return 1;
}

char isCompleted(int grid[N][N])
{
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            if (grid[i][j] != 0)
            {
                return 1;
            }
        }
    }
    return 0;
}
char solveSudoku(int grid[N][N])
{
    for (int row = 0; row < N; row++)
    {
        for (int col = 0; col < N; col++)
        {
            if (grid[row][col] == 0)
            {
                for (int num = 1; num <= N; num++)
                {
                    if (isValid(grid, row, col, num))
                    {
                        grid[row][col] = num;
                        if (solveSudoku(grid))
                        {
                            return 1;
                        }
                        grid[row][col] = 0; // Backtrack
                    }
                }
                return 0;
            }
        }
    }
    return 1; // Puzzle solved
}
void sudukoGenerate(int grid[N][N], int autogenerated[N][N]) {
    srand(time(NULL));
    int c = 0;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            c++;

            // Try numbers 1-9 until a valid number is found
            for (int num = 1; num <= N; num++) {
                int randNum = rand() % N + 1;
                if (isValid(grid, i, j, randNum)) {
                    grid[i][j] = randNum;
                    autogenerated[i][j] = 1; // Mark as autogenerated
                    break;
                }
            }
        }
    }
}


void modifySudoku(int grid[N][N], int row, int col, int autogenerated[N][N]) {
    int val;

    printf("Enter row, column, and value (separated by spaces): ");
    scanf("%d%d%d", &row, &col, &val);

    if (row >= 0 && row < N && col >= 0 && col < N && autogenerated[row][col] == 0) {
        grid[row][col] = val;
    } else {
        printf("Invalid move. You can only modify new entered numbers.\n");
    }
}

int main() {
    int sudokuGrid[N][N] = {{0}};
    int autogenerated[N][N] = {0};
    
    sudukoGenerate(sudokuGrid, autogenerated);

    int exit = 1;
    int row = 0, col = 0, solveKey = 0;

    printGrid(sudokuGrid);

    while (exit != 0) {
        printf("Enter row and col number (0 to quit):\n");
        scanf("%d%d", &row, &col);

        if (row == 0 || col == 0) {
            printf("Quitting the game. Goodbye!\n");
            break;
        }

        if (row < 1 || col < 1 || row > N || col > N) {
            printf("Invalid position.... Try again!!\n");
            continue;
        }

        modifySudoku(sudokuGrid, row - 1, col - 1, autogenerated);

        printGrid(sudokuGrid);

        if (!isCompleted(sudokuGrid)) {
            printf("Congratulations! You have completed the Sudoku puzzle!\n");
            exit = 0;
        } else {
            printf("To continue playing press any Key\nTo Exit press 0\n");
            scanf("%d", &exit);
        }
    }

    printf("Display the Puzzle solution press 2: \n");
    scanf("%d", &solveKey);

    if (solveKey == 2) {
        solveSudoku(sudokuGrid);
        printGrid(sudokuGrid);
    }

    return 0;
}
