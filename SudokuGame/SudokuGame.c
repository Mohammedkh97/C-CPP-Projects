#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <windows.h>
#define N 9

// ANSI escape codes for text color (Windows)
#define COLOR_RESET "\033[0m"
#define COLOR_YELLOW "\033[1;33m"
#define COLOR_CYAN "\033[1;36m"
#define ANSI_COLOR_RED "\x1b[31m"
#define ANSI_COLOR_GREEN "\x1b[32m"
#define ANSI_COLOR_YELLOW "\x1b[33m"
#define ANSI_COLOR_RESET "\x1b[0m"

void printGrid(int grid[N][N])
{
    printf(" -------------------------------------------\n");
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            if (j == 0)
            {
                printf(" |");
            }
            printf("%3d ", grid[i][j]);
            if ((j + 1) % 3 == 0)
                printf(" |");
        }
        printf("\n");
        if ((i + 1) % 3 == 0)
        {
            printf(" -------------------------------------------\n");
        }
    }
}

// Function to check if a number is valid in a given row and column
char isValid(int grid[N][N], int row, int col, int num)
{

    for (int i = 0; i < N; i++)
    {
        if (grid[row][i] == num || grid[i][col] == num)
        {

            return 0;
        }
    }
    return 1;
}

// Function to check if the Sudoku Grid is full
char isCompleted(int grid[N][N])
{
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            if (grid[i][j] != 0)
            {
                return 1;
            }
        }
    }
    return 0;
}
// Function to solve the Sudoku puzzle using backtracking technique
char solveSudoku(int grid[N][N])
{
    for (int row = 0; row < N; row++)
    {
        for (int col = 0; col < N; col++)
        {
            if (grid[row][col] == 0)
            {
                for (int num = 1; num <= N; num++)
                {
                    if (isValid(grid, row, col, num))
                    {
                        grid[row][col] = num;
                        if (solveSudoku(grid))
                        {
                            return 1;
                        }
                        grid[row][col] = 0; // Backtrack
                    }
                }
                return 0;
            }
        }
    }
    return 1; // Puzzle solved
}
// Function to generate the initial and random numbers for Sudoku grid
void sudukoGenerate(int grid[N][N], int autogenerated[N][N])
{
    srand(time(NULL));
    int c = 0;
    int randRow = 0, randCol = 0;
    for (int i = 0; i < N; i = i + 3)
    {
        for (int num = 1; num <= N; num++)
        {
            randRow = i + rand() % 3;
            randCol = i + rand() % 3;
            if (grid[randRow][randCol] == 0 && isValid(grid, randRow, randCol, num))
            {
                grid[randRow][randCol] = num;
                autogenerated[randRow][randCol] = 1;
            }
        }
    }
    // printf("count = %d\n", c);
}
// Function to modify the Sudoku grid for the entered numbers by the user
void modifySudoku(int grid[N][N], int row, int col, int num, int autogenerated[N][N])
{
    if (row >= 0 && col >= 0 && row < N && col < N && autogenerated[row][col] == 0)
    {
        if (isValid(grid, row, col, num))
            grid[row][col] = num;
        else
        {
            printf("Invalid Move\n");
            Beep(900, 200);
            Beep(900, 200);
        }
    }
    else
    {
        printf(ANSI_COLOR_RED "Invalid Move. Modify only on New Entered Numbers.\n");
        printf("====================================================\n" ANSI_COLOR_RESET);
        Beep(500, 200);
        Beep(500, 200);
    }
}
// Function to print the Sudoku grid with colored new entered numbers
void printColoredGrid(int grid[N][N], int autogenerated[N][N])
{
    printf(" -------------------------------------------\n");
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            if (j == 0)
            {
                printf(" |");
            }
            if (autogenerated[i][j] == 1)
            {
                printf(COLOR_CYAN "%3d " COLOR_RESET, grid[i][j]); // Print autogenerated numbers in cyan
            }
            else if (grid[i][j] == 0)
            {
                printf(ANSI_COLOR_GREEN "%3d " COLOR_RESET, grid[i][j]); // Print new entered numbers in yellow
            }
            else
            {
                printf(COLOR_YELLOW "%3d " COLOR_RESET, grid[i][j]); // Print new entered numbers in yellow
            }
            if ((j + 1) % 3 == 0)
            {
                printf(" |");
            }
        }
        printf("\n");
        if ((i + 1) % 3 == 0)
        {
            printf(" -------------------------------------------\n");
        }
    }
}
void compareSolution(int sudokuGrid[N][N], int solutionGrid[N][N], int autogenerated[N][N])
{
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            solutionGrid[i][j] = sudokuGrid[i][j];
        }
    }
    if (solveSudoku(solutionGrid))
    {
        printf(ANSI_COLOR_GREEN "====================================================\n");
        printf("||           Sudoku puzzle solution:              ||\n");
        printf("====================================================\n" ANSI_COLOR_RESET);
        printGrid(solutionGrid);
        printf("====================================================\n");
    }
    else
    {
        printf(ANSI_COLOR_GREEN "====================================================\n");
        printf("||                  No solution exists            ||\n");
        printf("====================================================\n" ANSI_COLOR_RESET);
    }
}
void welcomeMessage()
{
    printf(ANSI_COLOR_GREEN "====================================================\n");
    printf("||                 Welcome to SUDOKU!             ||\n");
    printf("====================================================\n" ANSI_COLOR_RESET);
}
void byeMessage()
{
    printf(ANSI_COLOR_GREEN "====================================================\n");
    printf("||                  Thank You!                    ||\n");
    printf("||              GOOD BYE & GOOD LUCK              ||\n");
    printf("====================================================\n");
}

int main()
{
    int sudokuGrid[N][N] = {{0}};
    int autogenerated[N][N] = {0};
    int solutionGrid[N][N];

    int exit = 1;
    int knownkey = 0;
    int row = 0, col = 0, num = 0, solveKey = 0;
    sudukoGenerate(sudokuGrid, autogenerated);
    // printGrid(autogenerated);
    welcomeMessage();
    printGrid(sudokuGrid);
    while (exit != 0)
    {
        printf(ANSI_COLOR_GREEN "Enter row and col number:\n" ANSI_COLOR_RESET);
        scanf("%d%d", &row, &col);
        printf(ANSI_COLOR_YELLOW "Enter a number from 1-9 in this position [%d][%d]: ", row, col);
        scanf("%d", &num);
        printf("====================================================\n" ANSI_COLOR_RESET);

        if (row == 0 && col == 0 && num == 0)
        {
            printf(ANSI_COLOR_GREEN"====================================================\n");
            printf( "||               Quitting the Game....            ||\n");
            printf("====================================================\n" ANSI_COLOR_RESET);
            printf(ANSI_COLOR_RED "Do you Want to Know The Solution?\n");
            printf("====================================================\n" ANSI_COLOR_RESET);
            printf("If Yes press 1\n===\nIf No press 0\n===\n");
            scanf("%d", &solveKey);
            if (solveKey)
            {
                solveSudoku(sudokuGrid);
                printColoredGrid(sudokuGrid, autogenerated);
                knownkey = 1;
                break;
            }
            else
                break;
        }
        if (row < 1 || col < 1 || row > N || col > N || num < 1 || num > 9)
        {
            printf(ANSI_COLOR_RED "Invalid position.... Try again!!\n" ANSI_COLOR_RESET);
            Beep(500, 200);
            Beep(500, 200);
            printf("====================================================\n");
            continue;
        }

        modifySudoku(sudokuGrid, row - 1, col - 1, num, autogenerated);
        // printGrid(sudokuGrid);
        printColoredGrid(sudokuGrid, autogenerated);
        if (!isCompleted(sudokuGrid))
            printf("Congratulations! You have completed the Sudoku puzzle!\n");
        /*else
        {
            printf("To continue playing press any Key\nTo Exit press 0\n");
            scanf("%d", &exit);
        }*/
    }
    if (knownkey == 1)
    {
        byeMessage();
        return 0;
    }
    else
    {
        printf("====================================================\n");
        printf("Are you sure you don't want to know the Puzzle solution?\n====================================================\nIf Yes press 1\n===\nIf No press 0\n===\n");
        scanf("%d", &solveKey);
        if (solveKey == 0)
        {
            // printf("Do you solve it Successfully ?\nPress 2 to make sure\n");
            compareSolution(sudokuGrid, solutionGrid, autogenerated);
        }
        else if (solveKey == 1)
        {
            byeMessage();
        }
    }
    return 0;
}
